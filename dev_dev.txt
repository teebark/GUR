create or replace PACKAGE BODY                                             pkg_development_reserve AS
PROCEDURE process_dev_rsrv_rcrds_btch (parm_targets in gurowner.dev_targets%rowtype, 
  account_date in Date, parm_runid in varchar2, parmbuf out varchar2, parmcode out varchar2, limit_in IN PLS_INTEGER DEFAULT 200)
  is
  /*------------------------------------------------------------
  Stored procedure for Ground Up Reserving, Development process.
  This is a subroutine, called by process_dev_rsrv_rcrds.
  Input table is from Data Migrator, which converts the pending
  claims mainframe file to a table for processing here.
  There are several parm inputs, one of which is limit_in, for the
  number of records that cursor c1 uses for each bulk collection.
  Bulk collection is used instead of select/fetch as it's more
  efficient for large tables. A full cursor call can create 
  memory problems, so smaller numbers of rows are read at a time to 
  alleviate this problem. The number of rows processed at a time
  is determined by the value for limit_in.
  The code is executed multiple times, using dev_targets as
  a driver. This procedure, process_dev_rsrv_rcrds_btch, is called by 
  process_dev_rsrv_rcrds.
  Each row of the targets table executes the complete subroutine code.
  Parms:
  1. parm_targets--a targets row, passed from process_dev_rsrv_rcrds.
  2. account_date--as of processing date, passed from process_dev_rsrv_rcrds.
  3. parmbuf--return error message to process_dev_rsrv_rcrds.
  4. parmcode--return error code to process_dev_rsrv_rcrds.
  5. limit_in--a value for the   number of records that cursor c1 uses for each
     bulk collection. Defaults to 100.
  Input:
  1. Pending claims table, via Data Migrator and the main program, 
     process_dev_rsrv_rcrd.
  2. dev_targets--this is the driver for executing the code.
  3. The 9 grouping tables--for determing what rows to process.
  4. dev_factors--for computing spread values.
  Output:
  1. dev_adj_run--one row is created for each dev_targets row. It
     contains an ID column as a parent key for the dev_adjstmnts
     table. The ID key is generated by an Oracle sequence table.
  2. dev_adjstmnts--copy of all input rows processed, with field
     caseadj containing the spread amount.
  Program logic:
  1. User cursor c2 to read the driver table, dev_targets.
  2. Use cursor c1 to process each row selected by the grouping
     tables.
  3. Call c1 three times--the first time to summarize case reserves,
     repsread sum, and respread above threshhold. The second time
     to summarize target spread. The third time to compute the
     final spread and create the output table.
  4. If there are more rows in dev_targets to process, loop
     again, starting at #1, until there are no more rows.
  ----------------------------------------------------------
  Changed       By               Description
  ---------- -------- --------------------------------------
  2015/11/20 T.Barker Removed state from target grouping and
                      replaced coverage with paired coverage/
                      state grouping.
  2015/12/18 T.Barker Added a correction for round off error
                      within a coverage/feature group.
                      Added claim symbol and claimant to sort
                      so rounding will affect the first
                      feature in claim symbol/claimant order.
  2016/02/24 T.Barker Copied new field ftr_rsv_amnt to
                      dev_adjstmnts table. Also added age. 
 2016/3/30   T.Barker Added new balance table and balance
                      processing.
  ----------------------------------------------------------
  For use in a bulk select, create associative arrays. There is 
  one of these for each column in the input rows, plus one for
  a computed field, feat_cnt. For each bulk collection execution,
  an array is populated with the rows determined by the cursor.
  The array variables are identified by the suffix 'tt'.
  ----------------------------------------------------------*/
  type acc_dt_tt is table of Date index by pls_integer;
  l_acc_dt acc_dt_tt;
  type avg_case_tt is table of char(1) index by pls_integer;
  l_avg_case avg_case_tt;
  type case_res_tt is table of number(11,2) index by pls_integer;
  l_case_res case_res_tt;
  type feat_res_tt is table of number(9,2) index by pls_integer;
  l_feat_res feat_res_tt;
  type age_tt is table of number(3) index by pls_integer;
  l_age age_tt;
  type rated_st_tt is table of char(2) index by pls_integer;
  l_rated_st rated_st_tt;
  dev_reserve GUROWNER.DEV_CL_CLMS.CSE_RSV_AMNT%type;
  type claim_no_tt is table of char(16) index by pls_integer;
  l_claim_no claim_no_tt;
  type feat_cnt_tt is table of number index by pls_integer;
  l_feat_cnt feat_cnt_tt;
  type cmpny_cd_tt is table of char(2) index by pls_integer;
  l_cmpny_cd cmpny_cd_tt;
  type CVRG_CD_tt is table of char(3) index by pls_integer;
  l_CVRG_CD CVRG_CD_tt;
  type veh_type_tt is table of char(3) index by pls_integer;
  l_veh_type veh_type_tt;
  type LOB_CD_tt is table of char(3) index by pls_integer;
  l_LOB_CD LOB_CD_tt;
  type risk_seg_tt is table of char(1) index by pls_integer;
  l_risk_seg risk_seg_tt;
  type rate_struc_tt is table of char(1) index by pls_integer;
  l_rate_struc rate_struc_tt;
  type policy_yrs_tt is table of char(2) index by pls_integer;
  l_policy_yrs policy_yrs_tt;
  type priv_pass_tt is table of char(1) index by pls_integer;
  l_priv_pass priv_pass_tt;
  type CLM_SMBL_tt is table of char(3) index by pls_integer;
  l_CLM_SMBL CLM_SMBL_tt;
  type claimant_tt is table of char(2) index by pls_integer;
  l_claimant claimant_tt;
  type l_factor_tt is table of number(6,4) index by pls_integer;
  l_factor l_factor_tt;
  type case_split_tt is table of number(20,8) index by pls_integer;
  l_case_split case_split_tt;
  type dev_res_tt is table of number(20,8) index by pls_integer;
  l_dev_res dev_res_tt;
  target_id       parm_targets.dev_targets_id%type := parm_targets.dev_targets_id;
  threshld        parm_targets.thrshld%type        := parm_targets.thrshld;
  target          parm_targets.trgt%type           := parm_targets.trgt;
  target_filename parm_targets.filename%type       := rtrim(parm_targets.filename);

  
  adj_run_seq number (38);
  start_tm number(12);
  pass1_tm number(12);
  pass2_tm number(12);
  pass3_tm number(12);
  elapsed number(12);
  c_yes char(1) := 'Y';
  c_active char(1) := 'Y';
  c_dev char(1) := 'D';
  c_zero number(1) := 0;
  c_one number(1) := 1;
  c_two char(1) := '2';
  c_120 number(3) := 120;
  run_log_seq number(38,0);
  reserve_above GUROWNER.DEV_CL_CLMS.CSE_RSV_AMNT%type;
  factor number(6,5);
  numberofFactors number(3):=0;
  ageMonths number(3) := null;
  case_res_split GUROWNER.DEV_CL_CLMS.CSE_RSV_AMNT%type;
  CASE_SUM number(15,2) := 0; 
  --total_res number(15,2) :=0; -- modified to resolve rounding issue crating out of balance condition
  total_res number(20,8) :=0;
  total_res_round number(20,2) :=0;
  
  total_res_num number(15,0) :=0;
  DEV_RES_SUM  number(20,8) := 0;       
  RES_ABOVE_SUM number(20,8) := 0;
  final_sum number(20,8) := 0;
  target_sum number(20,8) := 0;
  respread number(20,8) := 0;
  adj_amt number(20,8) := 0;
  target_ratio number(20,8);
  target_spread_ratio number(20,8);
  target_spread number(20,8);
  target_respread number(20,8);
  dev_reserve_cvg number(20,8);
  respread_cvg number(20,8);
  adj_amt_cvg number(20,8);
  target_above number(20,8);
  target_above_sum number(20,8) := 0;
  reserve_final number(20,8);
  target_final_sum number(20,8) := 0;
  target_final number(20,8);
  final_cov number(20,8);
  final_feat number(20,8);
  tot_count number(15);
  i integer := 0;
  prev_cov char(3) := null;
  prev_claim char(18) := null;
  firstbuf varchar2(200) := null;
  firstcode varchar2(3) := null;
  TRUNC_FEAT number(12,2);
  ROUND_COV number(12,2);
  COV_DIFF number(6,2);
  first_feat char(1) := 'N';
  /*----------------------------------------------------------
  Set up to trap an overflow condition on the adjustment amt.
  ----------------------------------------------------------*/
  adj_overflow EXCEPTION;
  PRAGMA EXCEPTION_INIT(adj_overflow,-01438);
  /*----------------------------------------------------------
  This cursor has the following functions:
  1. Filter by the 9 group attributes.
  2. Where avgcase = 2 and case amt > 0.
  3. Add the feature count for each feature row on
  the input file. It joins the input table with another 
  version of the same table that is grouped by coverage.
  4. Sum the case amounts for computation in the 2nd pass.
  ----------------------------------------------------------*/
  cursor c1 is
    select ta.CVRG_CD, ta.CSE_RSV_AMNT, ta.ftr_rsv_amnt, age,
      ta.AVE_CASE_IND, ta.CLM_NMBR, ta.ACDNT_DT, ta.veh_type, 
      ta.LOB_CD, ta.RT_ST_CD, ta.RSK_SGMT_CD,
      ta.RT_STRCTR_CD, ta.YRS_INSRD_CD, ta.PRVT_PSNGR_CD, ta.CLM_SMBL, ta.CLMNT, 
      ta.cmpny_cd, tb.feat_cnt, fctr,
      ta.CSE_RSV_AMNT / tb.feat_cnt as CASE_RES_SPLIT,
      (ta.CSE_RSV_AMNT / tb.feat_cnt) * fctr as DEV_RESERVE
    from (select CLM_NMBR as ID, CVRG_CD, CSE_RSV_AMNT, ftr_rsv_amnt,
      AVE_CASE_IND, CLM_NMBR, ACDNT_DT, VHCL_TYP_CD as veh_type, 
      LOB_CD, RT_ST_CD, RSK_SGMT_CD, RT_STRCTR_CD, YRS_INSRD_CD, PRVT_PSNGR_CD, CLM_SMBL, CLMNT, 
      cmpny_cd
        from GUROWNER.DEV_CL_CLMS) ta
    inner join (select CLM_NMBR, CVRG_CD, count(CLM_NMBR) as feat_cnt from GUROWNER.DEV_CL_CLMS 
    group by CLM_NMBR, CVRG_CD) tb
    on ta.CLM_NMBR = tb.CLM_NMBR and
      ta.CVRG_CD = tb.CVRG_CD and
      ta.AVE_CASE_IND = c_two and ta.CSE_RSV_AMNT > c_zero
    inner join gurowner.dev_factors
       on dev_factors_id = target_id 
       and age = 
       (case 
       when floor(months_between(account_date,acdnt_dt)) + c_one > c_120 THEN c_120
       else floor(months_between(account_date,acdnt_dt)) + c_one
       end)
     where exists
      (select 1
       from gurowner.res_cmpny_grp a
       where a.cmpny_grp = parm_targets.cmpny_grp
       and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.cmpny_cd=ta.cmpny_cd)  
     and ta.cvrg_cd || ta.rt_st_cd in
      (select b.cvrg_cd || a.rt_st_cd
       from gurowner.cvrg_rt_st_grp a
       inner join gurowner.res_cvrg_grp b
       on a.cvrg_rt_st_grp = parm_targets.cvrg_rt_st_grp
       and a.cvrg_grp = b.cvrg_grp
       and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev
       and b.ACTV_IN=c_yes and b.RSRV_TYP=c_dev)
     --and exists
     -- (select 1
     --  from gurowner.res_lob_grp a       
     --  where a.lob_grp = parm_targets.lob_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.LOB_CD=ta.LOB_CD)
     --and exists
     -- (select rsk_sgmt_cd
     --  from gurowner.res_rsk_sgmt_grp a       
     --  where a.rsk_sgmt_grp = parm_targets.rsk_sgmt_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.RSK_SGMT_CD=ta.RSK_SGMT_CD)
     --and exists
     -- (select 1
     --  from gurowner.res_rt_strctr_grp a
     --  where a.rt_strctr_grp = parm_targets.rt_strctr_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.RT_STRCTR_CD=ta.RT_STRCTR_CD)
     --and exists
     -- (select 1
     --  from gurowner.clm_vhcl_typ_grp a       
     --  where a.vhcl_typ_grp = parm_targets.vhcl_typ_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.vhcl_typ_cd=ta.VEH_TYPE)
     --and exists
     -- (select 1
     --  from gurowner.yrs_insrd_grp a       
     --  where a.yrs_insrd_grp = parm_targets.yrs_insrd_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.yrs_insrd_cd = ta.YRS_INSRD_CD)
     --and exists 
     -- (select 1
     --  from gurowner.prvt_psngr_grp a       
     --  where a.prvt_psngr_grp = parm_targets.prvt_psngr_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev AND a.PRVT_PSNGR_CD=ta.PRVT_PSNGR_CD)
--and rownum <= 100
  order by ta.id, ta.cvrg_cd, ta.CLM_SMBL, ta.CLMNT;
  
  BEGIN
    /*----------------------------------------------------------
    Write title line for first pass calculations.
    ----------------------------------------------------------*/
--  DBMS_OUTPUT.PUT_LINE('CO     CLAIM_NO     ACC_DT  CASE_RES SPLIT' ||
--  '  ST AGE FACT RESERVE   ABOVE  ' ||
--  '   CNT CASE SUM  RES SUM  ABOVE SUM');
--  --DBMS_OUTPUT.PUT_LINE ('Line Number, ');
    /*----------------------------------------------------------
    First pass--summarize case reserve.
    ---------------------------------------------------------*/
    start_tm := Dbms_Utility.Get_Time;
    --dbms_output.put_line('start = ' || to_char(start_tm));
    select 
      sum(ta.CSE_RSV_AMNT / tb.feat_cnt) as case_sum,
      sum((ta.CSE_RSV_AMNT / tb.feat_cnt) * fctr) as dev_res_sum,
      sum(Case WHEN ta.CSE_RSV_AMNT >= threshld THEN (ta.CSE_RSV_AMNT / tb.feat_cnt) * fctr
           ELSE c_zero END) as res_above_sum,
      count(*) as tot_count
    into case_sum, dev_res_sum, res_above_sum, tot_count
    from (select CLM_NMBR as ID, CVRG_CD, CSE_RSV_AMNT, AVE_CASE_IND, CLM_NMBR,
      ACDNT_DT, VHCL_TYP_CD as veh_type, LOB_CD, RT_ST_CD, RSK_SGMT_CD,
      RT_STRCTR_CD, YRS_INSRD_CD, PRVT_PSNGR_CD, CLM_SMBL, CLMNT, cmpny_cd
        from GUROWNER.DEV_CL_CLMS) ta
    inner join (select CLM_NMBR, CVRG_CD, count(CLM_NMBR) as feat_cnt from GUROWNER.DEV_CL_CLMS 
      group by CLM_NMBR, CVRG_CD) tb
    on ta.CLM_NMBR = tb.CLM_NMBR and
      ta.CVRG_CD = tb.CVRG_CD and
      ta.AVE_CASE_IND = c_two and ta.CSE_RSV_AMNT > c_zero
    inner join gurowner.dev_factors
       on dev_factors_id = target_id 
       and age = 
       (case 
       when floor(months_between(account_date,acdnt_dt)) + c_one > c_120 THEN c_120
       else floor(months_between(account_date,acdnt_dt)) + c_one
       end)
     and exists
      (select 1
       from gurowner.res_cmpny_grp a
       where a.cmpny_grp = parm_targets.cmpny_grp
       and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.cmpny_cd=ta.cmpny_cd)  
     and ta.cvrg_cd || ta.rt_st_cd in
      (select b.cvrg_cd || a.rt_st_cd
       from gurowner.cvrg_rt_st_grp a
       inner join gurowner.res_cvrg_grp b
       on a.cvrg_rt_st_grp = parm_targets.cvrg_rt_st_grp
       and a.cvrg_grp = b.cvrg_grp
       and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev
       and b.ACTV_IN=c_yes and b.RSRV_TYP=c_dev)
     --and exists
     -- (select 1
     --  from gurowner.res_lob_grp a       
     --  where a.lob_grp = parm_targets.lob_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.LOB_CD=ta.LOB_CD)
     --and exists
     -- (select rsk_sgmt_cd
     --  from gurowner.res_rsk_sgmt_grp a       
     --  where a.rsk_sgmt_grp = parm_targets.rsk_sgmt_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.RSK_SGMT_CD=ta.RSK_SGMT_CD)
     --and exists
     -- (select 1
     --  from gurowner.res_rt_strctr_grp a
     --  where a.rt_strctr_grp = parm_targets.rt_strctr_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.RT_STRCTR_CD=ta.RT_STRCTR_CD)
     --and exists
     -- (select 1
     --  from gurowner.clm_vhcl_typ_grp a       
     --  where a.vhcl_typ_grp = parm_targets.vhcl_typ_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.vhcl_typ_cd=ta.VEH_TYPE)
     --and exists
     -- (select 1
     --  from gurowner.yrs_insrd_grp a       
     --  where a.yrs_insrd_grp = parm_targets.yrs_insrd_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev and a.yrs_insrd_cd = ta.YRS_INSRD_CD)
     --and exists 
     -- (select 1
     --  from gurowner.prvt_psngr_grp a       
     --  where a.prvt_psngr_grp = parm_targets.prvt_psngr_grp
     --  and a.ACTV_IN=c_yes and a.RSRV_TYP=c_dev AND a.PRVT_PSNGR_CD=ta.PRVT_PSNGR_CD)
     order by ta.id, ta.cvrg_cd;
     --DBMS_OUTPUT.PUT_LINE (l_cmpny_cd(i) || ' '|| l_claim_no(i) ||
     --  ' ' || l_acc_dt(i) || '    ' || to_char(l_case_res(i)) || '   ' || to_char(case_res_split) || 
     --  '  ' || l_rated_st(i) || '  ' || to_char(ageMonths) || '  ' || to_char(factor) || '  ' || to_char(dev_reserve) ||
     --  '   ' || to_char(reserve_above) || '     ' || to_char(l_feat_cnt(i)) || 
     --  '    ' || to_char(case_sum) || '     ' || to_char(dev_res_sum) || '    ' || to_char(res_above_sum));
    --DBMS_OUTPUT.PUT_LINE ('case sum = ' || to_char(case_sum) || ', count = ' || to_char(tot_count) ||
    --  '    ' || to_char(dev_res_sum) || '    ' || to_char(res_above_sum));
    pass1_tm := dbms_utility.get_time;
    elapsed := pass1_tm - start_tm;
    --dbms_output.put_line('pass1 elapsed = ' || to_char(elapsed ));
    /*----------------------------------------------------------         
    The only way age can be null at this point is if the first
    fetch returned zero rows. We may want to abort here, but
    right now just show the error.
    ----------------------------------------------------------*/  
   
    if case_sum is null then
      --DBMS_OUTPUT.PUT_LINE ('No data matches this target grouping, ' || target_filename
      --  || ', ID = ' || to_char(target_id));
      parmcode := '002';
      parmbuf := 'No data matches this target grouping, ' || target_filename
        || ', ID = ' || to_char(target_id);
      if firstcode is null then
         firstbuf := parmbuf;
         firstcode := parmcode;
      end if;
    end if;
    /*----------------------------------------------------------
    Write title line for 2nd pass calculations.
    ----------------------------------------------------------*/
    --DBMS_OUTPUT.PUT_LINE('CO     CLAIM_NO          RES FINL' ||
    --'       FINL SUM   TARG RATIO  TARG SPRD    TARG SUM    FINL COV' ||
    --'  ROUND FEAT  ROUND COV  COV DIFF   ADJ AMT   FINL FEAT  TARG ABV   TARG ABV SUM');
    /*----------------------------------------------------------         
    Second pass(reserve calculations), summarize target_above.             
    ----------------------------------------------------------*/  
    open c1;
    LOOP
      fetch c1 bulk collect into l_CVRG_CD, l_case_res, 
        l_feat_res, l_age,
        l_avg_case, l_claim_no,  
        l_acc_dt,  l_veh_type, 
        l_LOB_CD, l_rated_st, l_risk_seg, l_rate_struc, l_policy_yrs, l_priv_pass, 
        l_CLM_SMBL, l_claimant, l_cmpny_cd, l_feat_cnt,
        l_factor, l_case_split, l_dev_res
        limit limit_in;
        EXIT WHEN l_acc_dt.count = 0;
      for i in 1 .. l_acc_dt.count
      LOOP
        if case_sum = 0 then
          respread := 0;
          parmcode := '005';
          parmbuf := 'Zero divide for case_sum, claim = ' || l_claim_no(i)
            || ', Target ID = ' || to_char(target_id);
          if firstcode is null then
            firstbuf := parmbuf;
            firstcode := parmcode;
          end if;
        else
          RESPREAD := l_case_split(i) * RES_ABOVE_SUM / CASE_SUM; 
        end if;
        IF L_CASE_RES(i) >= THRESHLD THEN  
          RESERVE_FINAL := RESPREAD;                     
        ELSE                                                  
          RESERVE_FINAL := RESPREAD + l_dev_res(i);   
        end if;
        FINAL_SUM := FINAL_SUM + RESERVE_FINAL;      
                
        /*----------------------------------                         
        SPREAD BASE RATIO                                    
        *---------------------------------*/  
        if dev_res_sum = 0 then
          target_ratio := 0;
          parmcode := '006';
          parmbuf := 'Zero divide for dev_res_sum, claim = ' || l_claim_no(i)
          || ', Target ID = ' || to_char(target_id);
          if firstcode is null then
            firstbuf := parmbuf;
            firstcode := parmcode;
          end if;
        else
          TARGET_RATIO := TARGET / DEV_RES_SUM; 
        end if;          
        /*-----------------------------------                          
        DEV RESERVE SPREAD AMT;                               
        *----------------------------------*/                        
        TARGET_SPREAD := l_dev_res(i) * TARGET_RATIO;           
        IF L_CASE_RES(i) >= THRESHLD THEN                          
           FINAL_COV := RESPREAD * l_feat_cnt(i);                  
        ELSE                                                
           FINAL_COV := (TARGET_SPREAD + RESPREAD) * l_feat_cnt(i);
        end if;
        FINAL_FEAT := FINAL_COV / l_feat_cnt(i);
        TARGET_SUM := TARGET_SUM + TARGET_SPREAD;      
        /*----------------------------------    
        START CALCULATION   - AFTER DECIDING  TARGET OR RESERVE 
        *----------------------------------*/    
        IF L_CASE_RES(i) >= THRESHLD THEN      
           TARGET_ABOVE := TARGET_SPREAD; 
        ELSE                             
           TARGET_ABOVE := 0;    
        end if;
        TARGET_ABOVE_SUM := TARGET_ABOVE_SUM + TARGET_ABOVE; 
        if target = 0 then  -- this means this is a reserver calculation, 
           adj_amt := reserve_final;
           adj_amt_cvg := adj_amt * l_feat_cnt(i);
           ROUND_COV := adj_amt_cvg;
           adj_amt := round_cov / l_feat_cnt(i);
           adj_amt := trunc(adj_amt,2);
           trunc_feat := adj_amt;
           if l_CVRG_CD(i) != prev_cov or
              l_claim_no(i) != prev_claim or
              prev_cov is null or
              prev_claim is null then
              --DBMS_OUTPUT.PUT_LINE ('break');
              /*----------------------------------------------------------
              Use gur_dev_seq.currval to use the same sequence number that
              was generated for the insert into the parent table,
              dev_adj_run.
              Run_id is omitted on purpose.
              ----------------------------------------------------------*/
              insert into GUROWNER.DEV_ADJSTMNTS_BAL
                (dev_adjstmnts_id, filename, RUN_ID, accdnt_yr, accdnt_mnth, rcrd_id,
                cmpny_cd, clm_nmbr, rsk_sgmt_cd, rt_strctr_cd,
                rt_st_cd, lob_cd, vhcl_typ_cd, prvt_psngr_cd, yrs_insrd_cd, cvrg_cd,
                clm_smbl, clmnt, cse_rsv_amnt, DEV_ADJ_AMT, ftr_rsv_amnt, age)
              values
               (GUROWNER.GUR_DEV_SEQ.currval, target_filename, parm_runid,to_char(l_acc_dt(i),'yy'), to_char(l_acc_dt(i),'mm'),
               'C', l_cmpny_cd(i), l_claim_no(i), l_risk_seg(i),
               l_rate_struc(i), l_rated_st(i), l_LOB_CD(i), l_veh_type(i), l_priv_pass(i),
               l_policy_yrs(i), l_CVRG_CD(i), ' ', ' ',
               l_case_res(i), adj_amt_cvg,'',l_age(i));
              first_feat := 'Y';
            end if;
            if first_feat = 'Y' then
               COV_DIFF := round_cov - trunc_feat * l_feat_cnt(i);         
               IF COV_DIFF = 0 THEN
                  null;
               else
                  adj_amt := trunc_feat + COV_DIFF;
               end if;   
               first_feat := 'N';
            end if;
            insert into GUROWNER.DEV_ADJSTMNTS_BAL
              (dev_adjstmnts_id, filename,run_id,  accdnt_yr, accdnt_mnth, rcrd_id,
              cmpny_cd, clm_nmbr, rsk_sgmt_cd, rt_strctr_cd,
              rt_st_cd, lob_cd, vhcl_typ_cd, prvt_psngr_cd, yrs_insrd_cd, cvrg_cd,
              clm_smbl, clmnt, cse_rsv_amnt, DEV_ADJ_AMT, ftr_rsv_amnt,age)
            values
             (GUROWNER.GUR_DEV_SEQ.currval, target_filename, parm_runid,  to_char(l_acc_dt(i),'yy'), to_char(l_acc_dt(i),'mm'),
             'F', l_cmpny_cd(i), l_claim_no(i), l_risk_seg(i),
             l_rate_struc(i), l_rated_st(i), l_LOB_CD(i), l_veh_type(i), l_priv_pass(i),
             l_policy_yrs(i), l_CVRG_CD(i), l_CLM_SMBL(i), l_claimant(i),
             l_case_res(i), adj_amt, l_feat_res(i), l_age(i));
           prev_cov := l_CVRG_CD(i);
           prev_claim := l_claim_no(i);
           /*----------------------------------------------------------  
            Collect balancing numbers. - first one here is reserve calc
            ----------------------------------------------------------*/  
           total_res := total_res + l_case_split(i);
           total_res_num := total_res_num + 1; --this is the row count
         
        end if;

           --DBMS_OUTPUT.PUT_LINE (l_cmpny_cd(i) || ' '|| l_claim_no(i) 
           --  || '   ' || to_char(reserve_final) || '    ' || to_char(final_sum) || '     ' 
           --  || to_char(target_ratio) || '     ' || to_char(target_spread) || '     ' 
           --  || to_char(target_sum) || '    ' || to_char(final_cov) || '      '
           --  || to_char(round_feat) || '  ' || to_char(round_cov) || '   '
           --  || to_char(cov_diff) || '   ' || to_char(adj_amt) || '   '
           --  || to_char(final_feat) || '      '
           --  || to_char(target_above) || '    ' || to_char(target_above_sum));
    END LOOP;
  END LOOP;
  --DBMS_OUTPUT.PUT_LINE ('targ above = ' || to_char(TARGET_ABOVE_SUM) 
  --  || ', case sum = ' || to_char(case_sum));
  /*----------------------------------------------------------         
  Generate the next sequence value from gur_dev_seq for the row id.
  It can be set up by yourself, using your user id, but when we go
  prod, it has to be set up by an administrator.
  The one used here is:
  CREATE SEQUENCE u12a05.gur_dev_seq
  INCREMENT BY 1
  START WITH 1
  cache 20
  noorder; 
  gur.dev.seq.nextval, in the code below, creates the sequence number.
  ----------------------------------------------------------*/  
  --DBMS_OUTPUT.PUT_LINE ('gurowner.gur_dev_seq.nextval'|| gurowner.gur_dev_seq.nextval);
  /*----------------------------------------------------------         
  Third pass(target calcualtion), create the final spread.              
  ----------------------------------------------------------*/  
  --DBMS_OUTPUT.PUT_LINE('CO     CLAIM_NO     SPLIT  SPRD RATIO' ||
  --  '  TARG RSPRD  TARG FINL  ROUND FEAT  ROUND COV  COV DIFF    TARG FINL SUM');
  close c1;
  pass2_tm := dbms_utility.get_time;
  elapsed := pass2_tm - pass1_tm;
  
  --total_res := 666; --DEBUG BALANCE
  --dbms_output.put_line('pass2 elapsed = ' || to_char(elapsed));
  if target = 0 then -- this means we don't want target calc, bypass doing the target calc
    goto bypass_target;
  end if;
  open c1;
  LOOP
    fetch c1 bulk collect into l_CVRG_CD, l_case_res, 
      l_feat_res, l_age,
      l_avg_case, l_claim_no, 
      l_acc_dt,  l_veh_type,
      l_LOB_CD, l_rated_st, l_risk_seg, l_rate_struc, l_policy_yrs, l_priv_pass, 
      l_CLM_SMBL, l_claimant, l_cmpny_cd, l_feat_cnt,
      l_factor, l_case_split, l_dev_res
      limit limit_in;
      EXIT WHEN l_acc_dt.count = 0;
    for i in 1 .. l_acc_dt.count
    LOOP
      if case_sum = 0 then
        respread := 0;
        parmcode := '005';
        parmbuf := 'Zero divide for case_sum, claim = ' || l_claim_no(i)
          || ', Target ID = ' || to_char(target_id);
        if firstcode is null then
          firstbuf := parmbuf;
          firstcode := parmcode;
        end if;
      else
        RESPREAD := l_case_split(i) * RES_ABOVE_SUM / CASE_SUM; 
      end if;
      IF L_CASE_RES(i) >= THRESHLD THEN  
        RESERVE_FINAL := RESPREAD;                     
      ELSE                                                  
        RESERVE_FINAL := RESPREAD + l_dev_res(i);   
      end if;
      /*----------------------------------                         
      * SPREAD BASE RATIO;                                    
      *---------------------------------*/ 
      if dev_res_sum = 0 then
         target_ratio := 0;
         parmcode := '006';
         parmbuf := 'Zero divide for dev_res_sum, claim = ' || l_claim_no(i)
           || ', Target ID = ' || to_char(target_id);
         if firstcode is null then
           firstbuf := parmbuf;
           firstcode := parmcode;
         end if;
      else
        TARGET_RATIO := TARGET / DEV_RES_SUM; 
      end if;                           
      /*-----------------------------------                          
      * DEV RESERVE SPREAD AMT;                               
      *----------------------------------*/                        
      TARGET_SPREAD := l_dev_res(i) * TARGET_RATIO; 
      if case_sum = 0 then
        target_spread_ratio := 0;
        parmcode := '005';
        parmbuf := 'Zero divide for case_sum, claim = ' || l_claim_no(i);
        if firstcode is null then
          firstbuf := parmbuf;
          firstcode := parmcode;
        end if;
      else
        TARGET_SPREAD_RATIO := TARGET_ABOVE_SUM / CASE_SUM;  
      end if;
      TARGET_RESPREAD := TARGET_SPREAD_RATIO * l_case_split(i);
      IF l_CASE_RES(i) >= THRESHLD THEN   
         adj_amt := TARGET_RESPREAD;
      ELSE
         adj_amt := TARGET_RESPREAD + TARGET_SPREAD;
      end if; 
      adj_amt_cvg := adj_amt * l_feat_cnt(i);
      ROUND_COV := adj_amt_cvg;
      adj_amt := round_cov / l_feat_cnt(i);         
      adj_amt := trunc(adj_amt,2);
      trunc_feat := adj_amt;
      TARGET_FINAL_SUM := TARGET_FINAL_SUM + adj_amt; 
      --DBMS_OUTPUT.PUT_LINE ('claim = ' || l_claim_no(i)
      --  || ', covg = ' || l_cvrg_cd(i) || ' ' || prev_claim
      --  || ' ' || prev_cov);
      if l_CVRG_CD(i) != prev_cov or
         l_claim_no(i) != prev_claim or
         prev_cov is null or
         prev_claim is null then
         --DBMS_OUTPUT.PUT_LINE ('break');
         /*----------------------------------------------------------
         Use gur_dev_seq.currval to use the same sequence number that
         was generated for the insert into the parent table,
         dev_adj_run.
         Run_id is omitted on purpose.
         ----------------------------------------------------------*/
         insert into GUROWNER.DEV_ADJSTMNTS_BAL
          (dev_adjstmnts_id, filename, run_id, accdnt_yr, accdnt_mnth, rcrd_id,
          cmpny_cd, clm_nmbr, rsk_sgmt_cd, rt_strctr_cd,
          rt_st_cd, lob_cd, vhcl_typ_cd, prvt_psngr_cd, yrs_insrd_cd, cvrg_cd,
          clm_smbl, clmnt, cse_rsv_amnt, DEV_ADJ_AMT, ftr_rsv_amnt, age)
         values
          (GUROWNER.GUR_DEV_SEQ.currval, target_filename, parm_runid, to_char(l_acc_dt(i),'yy'), to_char(l_acc_dt(i),'mm'),
          'C', l_cmpny_cd(i), l_claim_no(i), l_risk_seg(i),
          l_rate_struc(i), l_rated_st(i), l_LOB_CD(i), l_veh_type(i), l_priv_pass(i),
          l_policy_yrs(i), l_CVRG_CD(i), ' ', ' ',
          l_case_res(i), adj_amt_cvg,'',l_age(i));
         first_feat := 'Y';
      end if;
      if first_feat = 'Y' then
         COV_DIFF := round_cov - trunc_feat * l_feat_cnt(i);       
         IF COV_DIFF = 0 THEN
            null;
         else
            adj_amt := trunc_feat + COV_DIFF;
         end if;   
         first_feat := 'N';
      end if;
      --dbms_output.put_line (' ID     ACDT CO     CLM_NMBR      RSK RT ST LOB  VH PP ' 
      --  || 'YRS COV SMB CLM   CASE   ADJ   FEAT  AGE');
      --dbms_output.put_line (GUROWNER.GUR_DEV_SEQ.currval || ' ' || l_acc_dt(i) || ' '
      --  || l_cmpny_cd(i)   || ' ' || l_claim_no(i)  || ' ' || l_risk_seg(i) || '   '
      --  || l_rate_struc(i) || ' ' || l_rated_st(i)  || ' ' || l_LOB_CD(i) || ' '
      --  || l_veh_type(i)   || '  ' || l_priv_pass(i) || '  ' || l_policy_yrs(i) || ' '
      --  || l_CVRG_CD(i)    || ' ' || l_CLM_SMBL(i)  || '  ' || l_claimant(i) || '   '
      --  || l_case_res(i)   || ' ' || adj_amt        || '  ' || l_feat_res(i) || '   '
      --  || l_age(i));
      insert into GUROWNER.DEV_ADJSTMNTS_BAL
        (dev_adjstmnts_id, filename, run_id, accdnt_yr, accdnt_mnth, rcrd_id,
        cmpny_cd, clm_nmbr, rsk_sgmt_cd, rt_strctr_cd,
        rt_st_cd, lob_cd, vhcl_typ_cd, prvt_psngr_cd, yrs_insrd_cd, cvrg_cd,
        clm_smbl, clmnt, cse_rsv_amnt, DEV_ADJ_AMT, ftr_rsv_amnt, age)
      values
        (GUROWNER.GUR_DEV_SEQ.currval, target_filename, parm_runid, to_char(l_acc_dt(i),'yy'), to_char(l_acc_dt(i),'mm'),
        'F', l_cmpny_cd(i), l_claim_no(i), l_risk_seg(i),
        l_rate_struc(i), l_rated_st(i), l_LOB_CD(i), l_veh_type(i), l_priv_pass(i),
        l_policy_yrs(i), l_CVRG_CD(i), l_CLM_SMBL(i), l_claimant(i),
        l_case_res(i), adj_amt, l_feat_res(i), l_age(i));
      prev_cov := l_CVRG_CD(i);
      prev_claim := l_claim_no(i);
      
            
      /*----------------------------------------------------------  
       Collect balancing numbers.  - target calc , second one
      ----------------------------------------------------------*/  
      total_res := total_res + l_case_split(i);
      total_res_num := total_res_num + 1;

      --DBMS_OUTPUT.PUT_LINE (l_cmpny_cd(i) || ' ' || l_claim_no(i) 
      --   || ' ' || to_char(l_case_split(i))
      --   || '   ' || to_char(target_spread_ratio)
      --   || '   ' || to_char(target_respread) || '        '  || to_char(adj_amt)
      --   || '  ' || to_char(trunc_feat) || '  ' || to_char(round_cov) 
      --   || '  ' || to_char(cov_diff) 
      --   || '      ' || to_char(target_final_sum));
      

    END LOOP;
  END LOOP;
  --DBMS_OUTPUT.PUT_LINE ('ratio = ' || to_char(target_ratio) 
  --|| ', target ratio = ' || to_char(target_spread_ratio) 
  --|| ', final sum = ' || to_char(target_final_SUM));
  --DBMS_OUTPUT.PUT_LINE ('target sum = ' || to_char(target_final_sum));
  close c1;
  pass3_tm := dbms_utility.get_time;
  elapsed := pass3_tm - pass2_tm;
  --dbms_output.put_line('pass3 elapsed = ' || to_char(elapsed));
  
  <<bypass_target>>
  if (firstcode < '900' or firstcode is null) and     -- totals do not match at line 709, delete parent row, so that no leftover data in the table if we have catastrphic error
     case_sum is not null then

--     if case_sum = total_res and   --- here keep into account the precision for decimal places that may create out of bnalance condition

     total_res_round := total_res ; --- to correct the rounding issue
     if case_sum = total_res_round and   --- here keep into account the precision for decimal places that may create out of bnalance condition
        tot_count = total_res_num then
        null;
     else
        firstbuf := 'Out of bal: bal res = ' || to_char(case_sum) 
          || ', bal num = ' || to_char(tot_count)
          || ', tot res = ' || to_char(total_res) 
          || ', tot num = ' || to_char(total_res_num);
        firstcode := '999';
        adj_run_seq := gurowner.gur_dev_seq.currval;
        delete from gurowner.dev_adj_run
          where dev_adj_run_id = adj_run_seq;
        if firstcode is null then
           firstbuf := parmbuf; 
           firstcode := parmcode;
        end if;
     end if;
   end if;
 
  --Dexit;BMS_OUTPUT.PUT_LINE('parmcode = ' || parmcode ||
  --   ', parmbuf = ' || parmbuf);
  /*----------------------------------------------------------  
  Use the sequence number set in the package definition.
  ----------------------------------------------------------*/  
  if run_log_started is null then 
     run_log_seq := gurowner.gur_dev_log_seq.nextval;
     run_log_started := 'Y';
  else
     run_log_seq := gurowner.gur_dev_log_seq.currval;
  end if;
  insert into gurowner.dev_run_log
    (log_id,target_id,filename,error_txt,thrshld,target,total_spread, run_ts)
  values
    (run_log_seq,target_id,target_filename,
     parmbuf,threshld,target,target_final_sum,current_timestamp);
  parmbuf := firstbuf;
  parmcode := firstcode;
  /*----------------------------------------------------------
  Exception processing.
  1. Check for an overflow in the adjustment amt.
  ----------------------------------------------------------*/
  EXCEPTION
    when adj_overflow then
      DBMS_OUTPUT.PUT_LINE('Adj amount overflow = ' || to_char(adj_amt_cvg));
END process_dev_rsrv_rcrds_btch;

PROCEDURE process_dev_rsrv_rcrds (errbuf  OUT VARCHAR2,retcode OUT VARCHAR2,
    account_date in Date, parm_filename in varchar2, limit_in IN PLS_INTEGER DEFAULT 200, PARM_RUNID IN VARCHAR2, PARM_RN_CNTRL_Q_ID IN VARCHAR2 )
 -- account_date in Date, parm_filename in varchar2, limit_in IN PLS_INTEGER DEFAULT 200  )
  is
  /*----------------------------------------------------------------------------
  This is the msain program, called from Data Migrator This programs calls a
  subroutine, process_dev_rsrv_rcrds_btch.
  Uses the dev_targets table as a driver, and calls process_dev_rsrv_rcrds_btch
  for each row fetched.
  Parms:
  1. errbuf--Return error message to Data Migrator.
  2. retcode--Return code to Data Migrator.
  3. account_date--as of processing date, passed from process_dev_rsrv_rcrds.
  4. parm_filename--file name passed from the target table, passed to the
     subroutine.
  5. limit_in--a value for the number of records that cursor c1 uses in
     process_dev_rsrv_rcrds_btch for each bulk collection call. Defaults to 100.
  Input:
  1. Pending claims table (cl_clms), via Data Migrator.
  2. dev_targets--this is the driver table for executing the code.
  ---------------------------------------------------------------------------*/
  parm_targets gurowner.dev_targets%rowtype;
  target_filename parm_targets.filename%type       := rtrim(parm_targets.filename);
  target_id       parm_targets.dev_targets_id%type := parm_targets.dev_targets_id;
  firstbuf  varchar2(200) := null;
  firstcode varchar2(3)   := null;
  parmbuf   varchar2(200) := null;
  parmcode  varchar2(3)   := null;
  Operation_Status  number (38);

  cursor c2 is
    /*----------------------------------------------------------
    This cursor retrieves the threshld, target amt from dev_targets.
    ----------------------------------------------------------*/
    select DEV_TARGETS_ID,FILE_ROW_NUM, FILENAME, RSK_SGMT_GRP, CMPNY_GRP, RT_STRCTR_GRP,
      CVRG_RT_ST_GRP, LOB_GRP, VHCL_TYP_GRP, YRS_INSRD_GRP, 
      PRVT_PSNGR_GRP, THRSHLD, TRGT
      from gurowner.dev_targets
      where filename = rtrim(parm_filename);
    --and rownum <= 10;
  BEGIN
    errbuf := null;
    retcode := null;
    if account_date is null then
       parmcode := '004';
       parmbuf := 'Account date is null-process terminated.';
       if firstcode is null then
         firstbuf := parmbuf;
         firstcode := parmcode;
         goto bypass_run;
       end if;
    end if;
    /* truncate bal table */
    delete from gurowner.dev_adjstmnts_bal;
    insert into gurowner.dev_adj_run
      (dev_adj_run_id,filename,accnt_dt,run_time,usr_id)
    values
      (gurowner.gur_dev_seq.nextval,rtrim(parm_filename),account_date,current_timestamp,user);
    --dbms_output.put_line ('key1 = ' || gurowner.gur_dev_seq.currval);
    open c2;
    LOOP
      /*----------------------------------------------------------
      Fetch the row and call the spread routine.
      ----------------------------------------------------------*/
      fetch c2 into parm_targets;
      EXIT WHEN c2%NOTFOUND OR c2%NOTFOUND IS NULL;
      --DBMS_OUTPUT.PUT_LINE('target id = ' || to_char(parm_targets.dev_targets_id)
      --|| ', filename = ' || parm_targets.filename 
      --|| ', threshld = ' || to_char(parm_targets.thrshld) 
      --|| ', target = ' || to_char(parm_targets.trgt));
      process_dev_rsrv_rcrds_btch(parm_targets, account_date, parm_runid, parmbuf, parmcode);
      
    if parmcode is null then
       null;
      else
      firstbuf := parmbuf;
      firstcode := parmcode;
    if parmcode > '900' then --- out of balance , inside a loop, exit from loop at this point because you are out of balance
      exit;
   end if;
  end if;
     
    END LOOP;
    if c2%rowcount = 0 then
       parmcode := '003';
       parmbuf := 'File name not found in targets table = ' || rtrim(parm_filename)
         || ', ID = ' || to_char(target_id);
       if firstcode is null then
         firstbuf := parmbuf;
         firstcode := parmcode;
       end if;
    end if;
    close c2;

--    if parmcode > '900' then  --- out of balance or catastrophic error like dup row , don't write to output tablem bypass
 --  null;
    if parmcode < '900' or parmcode is null then
       insert into gurowner.dev_adjstmnts
       (select *
        from gurowner.dev_adjstmnts_bal);
end if;

   if parmcode is null or parmcode = '0' then
      parmcode := '0';
      parmbuf := 'Normal end';
  end if;        
      UPDATE GUROWNER.RN_CNTRL_Q  SET RETURN_CD = parmcode , ERR_MSG = parmbuf,
      DT_UPDT = CURRENT_TIMESTAMP,  UPDT_USR_ID =  USER   
      WHERE RN_CNTRL_Q_ID = PARM_RN_CNTRL_Q_ID;

  <<bypass_run>>
    if parmcode is null or parmcode = '0' then
       errbuf := 'Normal end';
       retcode := '0';
    else
       errbuf := firstbuf;
       retcode := firstcode;
       end if;
--    commit;
     CLEAN_AVG_TRGTS_SVRTY(parm_filename,Operation_Status) ; 

    DBMS_OUTPUT.PUT_LINE('retcode = ' || retcode ||
       ', errbuf = ' || errbuf);
  END process_dev_rsrv_rcrds;

PROCEDURE LOAD_DEV_TRGTS_FCTRS (In_File_Name in varchar2, Operation_Status out number)is
  CURSOR CUR_DEV_TARGETS_FACTORS IS

SELECT FILE_ROW_NUM,
  FILE_NAME,
  RISK_SEGMENT_GRP,
  COMPANY_GRP,
  RATE_STRUCTURE_GRP,
  CVRG_RT_ST_GRP,
  LOB_GRP,
  VEHICLE_TYPE_GRP,
  YEARS_INSURED_GRP,
  PRIVATE_PASSENGER_GRP,
  THRESHOLD_AMOUNT,
  DEV_DOLLAR_TARGET,
  ACCIDENT_AGE_1,
  ACCIDENT_AGE_2,
  ACCIDENT_AGE_3,
  ACCIDENT_AGE_4,
  ACCIDENT_AGE_5,
  ACCIDENT_AGE_6,
  ACCIDENT_AGE_7,
  ACCIDENT_AGE_8,
  ACCIDENT_AGE_9,
  ACCIDENT_AGE_10,
  ACCIDENT_AGE_11,
  ACCIDENT_AGE_12,
  ACCIDENT_AGE_13,
  ACCIDENT_AGE_14,
  ACCIDENT_AGE_15,
  ACCIDENT_AGE_16,
  ACCIDENT_AGE_17,
  ACCIDENT_AGE_18,
  ACCIDENT_AGE_19,
  ACCIDENT_AGE_20,
  ACCIDENT_AGE_21,
  ACCIDENT_AGE_22,
  ACCIDENT_AGE_23,
  ACCIDENT_AGE_24,
  ACCIDENT_AGE_25,
  ACCIDENT_AGE_26,
  ACCIDENT_AGE_27,
  ACCIDENT_AGE_28,
  ACCIDENT_AGE_29,
  ACCIDENT_AGE_30,
  ACCIDENT_AGE_31,
  ACCIDENT_AGE_32,
  ACCIDENT_AGE_33,
  ACCIDENT_AGE_34,
  ACCIDENT_AGE_35,
  ACCIDENT_AGE_36,
  ACCIDENT_AGE_37,
  ACCIDENT_AGE_38,
  ACCIDENT_AGE_39,
  ACCIDENT_AGE_40,
  ACCIDENT_AGE_41,
  ACCIDENT_AGE_42,
  ACCIDENT_AGE_43,
  ACCIDENT_AGE_44,
  ACCIDENT_AGE_45,
  ACCIDENT_AGE_46,
  ACCIDENT_AGE_47,
  ACCIDENT_AGE_48,
  ACCIDENT_AGE_49,
  ACCIDENT_AGE_50,
  ACCIDENT_AGE_51,
  ACCIDENT_AGE_52,
  ACCIDENT_AGE_53,
  ACCIDENT_AGE_54,
  ACCIDENT_AGE_55,
  ACCIDENT_AGE_56,
  ACCIDENT_AGE_57,
  ACCIDENT_AGE_58,
  ACCIDENT_AGE_59,
  ACCIDENT_AGE_60,
  ACCIDENT_AGE_61,
  ACCIDENT_AGE_62,
  ACCIDENT_AGE_63,
  ACCIDENT_AGE_64,
  ACCIDENT_AGE_65,
  ACCIDENT_AGE_66,
  ACCIDENT_AGE_67,
  ACCIDENT_AGE_68,
  ACCIDENT_AGE_69,
  ACCIDENT_AGE_70,
  ACCIDENT_AGE_71,
  ACCIDENT_AGE_72,
  ACCIDENT_AGE_73,
  ACCIDENT_AGE_74,
  ACCIDENT_AGE_75,
  ACCIDENT_AGE_76,
  ACCIDENT_AGE_77,
  ACCIDENT_AGE_78,
  ACCIDENT_AGE_79,
  ACCIDENT_AGE_80,
  ACCIDENT_AGE_81,
  ACCIDENT_AGE_82,
  ACCIDENT_AGE_83,
  ACCIDENT_AGE_84,
  ACCIDENT_AGE_85,
  ACCIDENT_AGE_86,
  ACCIDENT_AGE_87,
  ACCIDENT_AGE_88,
  ACCIDENT_AGE_89,
  ACCIDENT_AGE_90,
  ACCIDENT_AGE_91,
  ACCIDENT_AGE_92,
  ACCIDENT_AGE_93,
  ACCIDENT_AGE_94,
  ACCIDENT_AGE_95,
  ACCIDENT_AGE_96,
  ACCIDENT_AGE_97,
  ACCIDENT_AGE_98,
  ACCIDENT_AGE_99,
  ACCIDENT_AGE_100,
  ACCIDENT_AGE_101,
  ACCIDENT_AGE_102,
  ACCIDENT_AGE_103,
  ACCIDENT_AGE_104,
  ACCIDENT_AGE_105,
  ACCIDENT_AGE_106,
  ACCIDENT_AGE_107,
  ACCIDENT_AGE_108,
  ACCIDENT_AGE_109,
  ACCIDENT_AGE_110,
  ACCIDENT_AGE_111,
  ACCIDENT_AGE_112,
  ACCIDENT_AGE_113,
  ACCIDENT_AGE_114,
  ACCIDENT_AGE_115,
  ACCIDENT_AGE_116,
  ACCIDENT_AGE_117,
  ACCIDENT_AGE_118,
  ACCIDENT_AGE_119,
  ACCIDENT_AGE_120
FROM TMP_DEV_TARGETS_FACTORS  
WHERE FILE_NAME=In_File_Name
ORDER BY FILE_ROW_NUM;
REC_DEV_TARGETS_FACTORS CUR_DEV_TARGETS_FACTORS%ROWTYPE;


ageFactor number(6,4);
fileName varchar2(100);
targetId number(38);
BEGIN
Operation_Status:=0;
Open CUR_DEV_TARGETS_FACTORS;
Loop
fetch CUR_DEV_TARGETS_FACTORS INTO REC_DEV_TARGETS_FACTORS;
exit when CUR_DEV_TARGETS_FACTORS%NOTFOUND;

--DBMS_OUTPUT.put_line(REC_DEV_TARGETS_FACTORS.RISK_SEGMENT_GRP);
fileName := REC_DEV_TARGETS_FACTORS.FILE_NAME;
targetId :=GUROWNER.GUR_TARGET_SEQ.NEXTVAL;
INSERT
INTO DEV_TARGETS
  (
    DEV_TARGETS_ID,
    FILE_ROW_NUM,
    FILENAME,
    RSK_SGMT_GRP,
    CMPNY_GRP,
    RT_STRCTR_GRP,
    CVRG_RT_ST_GRP,
    LOB_GRP,
    VHCL_TYP_GRP,
    YRS_INSRD_GRP,
    PRVT_PSNGR_GRP,
    THRSHLD,
    TRGT
  )
  VALUES
  (
    targetId,
    REC_DEV_TARGETS_FACTORS.FILE_ROW_NUM,
    REC_DEV_TARGETS_FACTORS.FILE_NAME,
    REC_DEV_TARGETS_FACTORS.RISK_SEGMENT_GRP,
    REC_DEV_TARGETS_FACTORS.COMPANY_GRP,
    REC_DEV_TARGETS_FACTORS.RATE_STRUCTURE_GRP,
    REC_DEV_TARGETS_FACTORS.CVRG_RT_ST_GRP,
    REC_DEV_TARGETS_FACTORS.LOB_GRP,
    REC_DEV_TARGETS_FACTORS.VEHICLE_TYPE_GRP,
    REC_DEV_TARGETS_FACTORS.YEARS_INSURED_GRP,
    REC_DEV_TARGETS_FACTORS.PRIVATE_PASSENGER_GRP,
    REC_DEV_TARGETS_FACTORS.THRESHOLD_AMOUNT,
    REC_DEV_TARGETS_FACTORS.DEV_DOLLAR_TARGET
  );

FOR i in 1..120
LOOP

ageFactor:= Case i
      WHEN 1 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_1
      WHEN 2 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_2
      WHEN 3 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_3
      WHEN 4 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_4
      WHEN 5 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_5
      WHEN 6 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_6
      WHEN 7 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_7
      WHEN 8 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_8
      WHEN 9 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_9
      WHEN 10 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_10
      WHEN 11 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_11
      WHEN 12 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_12
      WHEN 13 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_13
      WHEN 14 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_14
      WHEN 15 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_15
      WHEN 16 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_16
      WHEN 17 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_17
      WHEN 18 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_18
      WHEN 19 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_19
      WHEN 20 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_20
      WHEN 21 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_21
      WHEN 22 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_22
      WHEN 23 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_23
      WHEN 24 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_24
      WHEN 25 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_25
      WHEN 26 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_26
      WHEN 27 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_27
      WHEN 28 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_28
      WHEN 29 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_29
      WHEN 30 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_30
      WHEN 31 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_31
      WHEN 32 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_32
      WHEN 33 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_33
      WHEN 34 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_34
      WHEN 35 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_35
      WHEN 36 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_36
      WHEN 37 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_37
      WHEN 38 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_38
      WHEN 39 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_39
      WHEN 40 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_40
      WHEN 41 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_41
      WHEN 42 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_42
      WHEN 43 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_43
      WHEN 44 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_44
      WHEN 45 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_45
      WHEN 46 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_46
      WHEN 47 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_47
      WHEN 48 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_48
      WHEN 49 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_49
      WHEN 50 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_50
      WHEN 51 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_51
      WHEN 52 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_52
      WHEN 53 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_53
      WHEN 54 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_54
      WHEN 55 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_55
      WHEN 56 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_56
      WHEN 57 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_57
      WHEN 58 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_58
      WHEN 59 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_59
      WHEN 60 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_60
      WHEN 61 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_61
      WHEN 62 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_62
      WHEN 63 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_63
      WHEN 64 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_64
      WHEN 65 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_65
      WHEN 66 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_66
      WHEN 67 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_67
      WHEN 68 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_68
      WHEN 69 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_69
      WHEN 70 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_70
      WHEN 71 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_71
      WHEN 72 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_72
      WHEN 73 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_73
      WHEN 74 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_74
      WHEN 75 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_75
      WHEN 76 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_76
      WHEN 77 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_77
      WHEN 78 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_78
      WHEN 79 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_79
      WHEN 80 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_80
      WHEN 81 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_81
      WHEN 82 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_82
      WHEN 83 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_83
      WHEN 84 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_84
      WHEN 85 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_85
      WHEN 86 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_86
      WHEN 87 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_87
      WHEN 88 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_88
      WHEN 89 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_89
      WHEN 90 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_90
      WHEN 91 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_91
      WHEN 92 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_92
      WHEN 93 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_93
      WHEN 94 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_94
      WHEN 95 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_95
      WHEN 96 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_96
      WHEN 97 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_97
      WHEN 98 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_98
      WHEN 99 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_99
      WHEN 100 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_100
      WHEN 101 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_101
      WHEN 102 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_102
      WHEN 103 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_103
      WHEN 104 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_104
      WHEN 105 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_105
      WHEN 106 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_106
      WHEN 107 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_107
      WHEN 108 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_108
      WHEN 109 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_109
      WHEN 110 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_110
      WHEN 111 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_111
      WHEN 112 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_112
      WHEN 113 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_113
      WHEN 114 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_114
      WHEN 115 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_115
      WHEN 116 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_116
      WHEN 117 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_117
      WHEN 118 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_118
      WHEN 119 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_119
      WHEN 120 THEN REC_DEV_TARGETS_FACTORS.ACCIDENT_AGE_120
      END;

--DBMS_OUTPUT.put_line(ageFactor);
INSERT INTO DEV_FACTORS
  (DEV_FACTORS_ID, AGE, FCTR) VALUES
  (targetId, i, ageFactor);
  
END LOOP; 

END LOOP;
CLOSE CUR_DEV_TARGETS_FACTORS;

INSERT INTO TMP_DEV_TARGETS_FACTORS_ARCH
  SELECT * FROM TMP_DEV_TARGETS_FACTORS WHERE FILE_NAME=fileName  ;
  
DELETE FROM TMP_DEV_TARGETS_FACTORS WHERE  FILE_NAME = fileName;

--COMMIT;
Operation_Status:=1;
Exception 
WHEN OTHERS THEN
ROLLBACK;
Operation_Status:=-1;
END LOAD_DEV_TRGTS_FCTRS;

PROCEDURE APPLY_DEV_RUNID (In_File_Name in varchar2,In_RunId in varchar2,UserId in varchar2,
Operation_Status out number)is  
BEGIN
Operation_Status:=0;

UPDATE DEV_ADJSTMNTS
SET RUN_ID=In_RunId
WHERE FILENAME = In_File_Name;

UPDATE DEV_ADJ_RUN
SET RUN_ID=In_RunId
,USR_ID=UserId
WHERE FILENAME = In_File_Name;

UPDATE RN_CNTRL_Q
SET RUNID=In_RunId
,DT_UPDT = SYSDATE
,UPDT_USR_ID = UserId
WHERE  FILENAME = In_File_Name;

--COMMIT;
Operation_Status:=1;
Exception 
WHEN OTHERS THEN
ROLLBACK;
Operation_Status:=-1;
END APPLY_DEV_RUNID;
PROCEDURE CLEAN_DEV_TRGTS_FCTRS (In_File_Name in varchar2,Operation_Status out number)is  
BEGIN
Operation_Status:=0;

INSERT
INTO DEV_TARGETS_ARCH
  (
    DEV_TARGETS_ID,
    FILE_ROW_NUM,
    FILENAME,
    RSK_SGMT_GRP,
    CMPNY_GRP,
    RT_STRCTR_GRP,
    CVRG_RT_ST_GRP,
    LOB_GRP,
    VHCL_TYP_GRP,
    YRS_INSRD_GRP,
    PRVT_PSNGR_GRP,
    THRSHLD,
    TRGT,
    DT_UPDT
  )
SELECT DEV_TARGETS_ID,
  FILE_ROW_NUM,
  FILENAME,
  RSK_SGMT_GRP,
  CMPNY_GRP,
  RT_STRCTR_GRP,
  CVRG_RT_ST_GRP,
  LOB_GRP,
  VHCL_TYP_GRP,
  YRS_INSRD_GRP,
  PRVT_PSNGR_GRP,
  THRSHLD,
  TRGT,
  SYSDATE
FROM DEV_TARGETS WHERE FILENAME=In_File_Name
ORDER BY DEV_TARGETS_ID,FILE_ROW_NUM;

INSERT
INTO DEV_FACTORS_ARCH
  (
    DEV_FACTORS_ID,
    AGE,
    FCTR,
    DT_UPDT
  )
SELECT as1.DEV_FACTORS_ID, as1.AGE, as1.FCTR, SYSDATE FROM DEV_FACTORS as1
WHERE EXISTS (SELECT 1 FROM DEV_TARGETS at1 WHERE at1.DEV_TARGETS_ID =as1.DEV_FACTORS_ID
AND at1.FILENAME=In_File_Name
) order by as1.DEV_FACTORS_ID,as1.AGE;

DELETE
FROM DEV_FACTORS as1
WHERE EXISTS (SELECT 1 FROM DEV_TARGETS at1 WHERE at1.DEV_TARGETS_ID =as1.DEV_FACTORS_ID
AND at1.FILENAME=In_File_Name);

DELETE
FROM DEV_TARGETS WHERE FILENAME=In_File_Name;


COMMIT;
Operation_Status:=1;
Exception 
WHEN OTHERS THEN
ROLLBACK;
Operation_Status:=-1;
END CLEAN_DEV_TRGTS_FCTRS;

END PKG_DEVELOPMENT_RESERVE;